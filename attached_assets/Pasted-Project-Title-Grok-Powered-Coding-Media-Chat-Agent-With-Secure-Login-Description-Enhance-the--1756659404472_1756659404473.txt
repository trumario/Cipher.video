Project Title: Grok-Powered Coding & Media Chat Agent - With Secure Login

Description: Enhance the web-based agent with username/password login using Replit DB and bcrypt for secure credential storage. The app starts with a login/register tab; upon success, it reveals the chat and video tabs. Features stealthy dark theme (toggleable), Grok API integration for coding/charts, and video overlay.

Steps to Set Up and Run:
1. Create/update a Python repl in Replit.
2. Install dependencies: In Shell, run `pip install gradio requests opencv-python-headless ffmpeg-python bcrypt replit`.
3. Add your xAI API key: In Replit's Secrets, add `XAI_API_KEY` with your value from https://x.ai/api.
4. Paste the following code into main.py.
5. Run the repl: Click Run or `python main.py`. Access via webview URL. Default credentials: Register a new user or use test ones (hashed securely).

Full Code for main.py:

import requests
import gradio as gr
import json
import cv2
import subprocess
import os
import re
import bcrypt
from replit import db

# Constants
API_URL = "https://api.x.ai/v1/chat/completions"
DEFAULT_MODEL = "grok-code-fast-1"
VISION_MODEL = "grok-beta"
MAX_FAILED_ATTEMPTS = 5
SALT_ROUNDS = 12
OUTPUT_VIDEO_PATH = "output.mp4"
TEMP_VIDEO_SUFFIX = "_noaudio.mp4"

# Load API key securely
API_KEY = os.environ.get("XAI_API_KEY")
if not API_KEY:
    raise ValueError("XAI_API_KEY not set in environment variables.")

# Custom CSS (unchanged from previous)
CUSTOM_CSS = """
:root {
    --primary-color: #4a4a4a;
    --bg-color: #1e1e1e;
    --text-color: #d4d4d4;
    --input-bg: #2a2a2a;
    --button-bg: #3a3a3a;
    --button-hover: #4a4a4a;
    --border-color: #3a3a3a;
}

.light {
    --primary-color: #007bff;
    --bg-color: #ffffff;
    --text-color: #333333;
    --input-bg: #f8f9fa;
    --button-bg: #e9ecef;
    --button-hover: #dee2e6;
    --border-color: #ced4da;
}

body {
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: 'Arial', sans-serif;
}

.gradio-container {
    background-color: var(--bg-color) !important;
    color: var(--text-color) !important;
    border: none !important;
}

input, textarea, .gr-textbox, .gr-chatbot {
    background-color: var(--input-bg) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

button {
    background-color: var(--button-bg) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

button:hover {
    background-color: var(--button-hover) !important;
}

.gr-tabitem {
    background-color: var(--input-bg) !important;
    color: var(--text-color) !important;
}

.gr-markdown {
    color: var(--text-color) !important;
}
"""

def hash_password(password: str) -> bytes:
    """Hash password securely using bcrypt."""
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(SALT_ROUNDS))

def check_password(stored_hash: bytes, password: str) -> bool:
    """Verify password against stored hash."""
    try:
        return bcrypt.checkpw(password.encode('utf-8'), stored_hash)
    except ValueError:
        return False

def register_user(username: str, password: str) -> str:
    """Register a new user with hashed password."""
    if username in db:
        return "Username already exists."
    if not username or not password:
        return "Username and password required."
    db[username] = hash_password(password)
    return "Registration successful. Please log in."

def login_user(username: str, password: str, state: dict) -> tuple[bool, str]:
    """Authenticate user and update state."""
    if "failed_attempts" not in state:
        state["failed_attempts"] = 0
    
    if state["failed_attempts"] >= MAX_FAILED_ATTEMPTS:
        return False, "Too many failed attempts. Try again later."
    
    stored_hash = db.get(username)
    if stored_hash and check_password(stored_hash, password):
        state["logged_in"] = True
        state["failed_attempts"] = 0
        return True, "Login successful."
    
    state["failed_attempts"] += 1
    return False, f"Invalid credentials. Attempts left: {MAX_FAILED_ATTEMPTS - state['failed_attempts']}"

def extract_image_url(message: str) -> str | None:
    """Extract potential image URL from message."""
    urls = re.findall(r'(https?://\S+\.(?:jpg|jpeg|png))', message, re.IGNORECASE)
    return urls[0] if urls else None

def query_grok(user_input: str, history: list = [], model: str = DEFAULT_MODEL, image_url: str | None = None) -> str:
    """Query Grok API with streaming support."""
    messages = [{"role": "system", "content": "You are a helpful assistant. For coding, use reasoning. For images, analyze details like charts."}]
    for human, ai in history:
        messages.append({"role": "user", "content": human})
        messages.append({"role": "assistant", "content": ai})
    
    if image_url:
        content = [{"type": "text", "text": user_input}, {"type": "image_url", "image_url": {"url": image_url, "detail": "auto"}}]
        messages.append({"role": "user", "content": content})
        model = VISION_MODEL
    else:
        messages.append({"role": "user", "content": user_input})
    
    response = requests.post(
        API_URL,
        headers={"Authorization": f"Bearer {API_KEY}", "Content-Type": "application/json"},
        json={
            "model": model,
            "messages": messages,
            "max_tokens": 1000,
            "temperature": 0.7,
            "stream": True
        },
        stream=True,
        timeout=30  # Add timeout for reliability
    )
    
    if response.status_code != 200:
        yield f"Error: {response.text}"
        return

    partial_message = ""
    for chunk in response.iter_lines():
        if chunk:
            try:
                chunk_data = chunk.decode('utf-8').strip()
                if chunk_data.startswith("data: "):
                    json_data = json.loads(chunk_data[6:])
                    delta = json_data.get("choices", [{}])[0].get("delta", {}).get("content", "")
                    if delta:
                        partial_message += delta
                        yield partial_message
            except (json.JSONDecodeError, ValueError):
                continue

def chat_fn(message: str, history: list, state: dict) -> str:
    """Chat function wrapper, requires login."""
    if not state.get("logged_in", False):
        return "Please log in first."
    image_url = extract_image_url(message)
    for partial in query_grok(message, history, image_url=image_url):
        yield partial

def overlay_videos(base_path: str, ghost_path: str, output_path: str, alpha: float = 0.5,
                   base_start_sec: float = 0.0, ghost_start_sec: float = 0.0, duration_sec: float | None = None) -> tuple[str | None, str]:
    """Overlay two videos with parameters."""
    cap_base = cv2.VideoCapture(base_path)
    cap_ghost = cv2.VideoCapture(ghost_path)
    
    if not cap_base.isOpened() or not cap_ghost.isOpened():
        return None, "Error opening video files."
    
    cap_base.set(cv2.CAP_PROP_POS_MSEC, base_start_sec * 1000)
    cap_ghost.set(cv2.CAP_PROP_POS_MSEC, ghost_start_sec * 1000)
    
    fps = cap_base.get(cv2.CAP_PROP_FPS)
    width = int(cap_base.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap_base.get(cv2.CAP_PROP_FRAME_HEIGHT))
    
    max_frames = int(duration_sec * fps) if duration_sec else None
    
    fourcc = cv2.VideoWriter_fourcc(*'H264')
    out = None
    try:
        out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
    except Exception:
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
    
    frame_count = 0
    while cap_base.isOpened() and cap_ghost.isOpened():
        if max_frames is not None and frame_count >= max_frames:
            break
        
        ret_base, frame_base = cap_base.read()
        ret_ghost, frame_ghost = cap_ghost.read()
        
        if not ret_base or not ret_ghost:
            break
        
        if frame_ghost.shape[:2] != (height, width):
            frame_ghost = cv2.resize(frame_ghost, (width, height))
        
        blended = cv2.addWeighted(frame_base, 1.0, frame_ghost, alpha, 0)
        out.write(blended)
        frame_count += 1
    
    cap_base.release()
    cap_ghost.release()
    out.release()
    
    try:
        temp_video = output_path + TEMP_VIDEO_SUFFIX
        os.rename(output_path, temp_video)
        result = subprocess.run([
            'ffmpeg', '-i', temp_video, '-i', base_path,
            '-c:v', 'copy', '-c:a', 'aac', '-map', '0:v:0', '-map', '1:a:0',
            output_path
        ], check=True, capture_output=True, text=True)
        os.remove(temp_video)
        return output_path, f"Processed {frame_count} frames with audio."
    except subprocess.CalledProcessError as e:
        return output_path, f"Video created, but audio muxing failed: {e.stderr}"
    except Exception as e:
        return output_path, f"Video created, but audio muxing failed: {str(e)}"

def process_videos(base_upload: str | None, ghost_upload: str | None, alpha: float, base_start: float,
                   ghost_start: float, duration: float | None, state: dict) -> tuple[str | None, str]:
    """Process video overlays, requires login."""
    if not state.get("logged_in", False):
        return None, "Please log in first."
    if not base_upload or not ghost_upload:
        return None, "Please upload both videos."
    return overlay_videos(base_upload, ghost_upload, OUTPUT_VIDEO_PATH, alpha, base_start, ghost_start, duration)

# Gradio UI
with gr.Blocks(title="Enhanced Coding & Media Agent", css=CUSTOM_CSS) as demo:
    state = gr.State({"logged_in": False, "failed_attempts": 0})
    
    gr.Markdown("Powered by Grok. Log in to access features.")
    
    with gr.Row():
        toggle_btn = gr.Button("Toggle Theme")
        toggle_btn.click(None, js="""() => { document.body.classList.toggle('light'); }""")
    
    with gr.Tab("Login/Register"):
        username = gr.Textbox(label="Username")
        password = gr.Textbox(label="Password", type="password")
        with gr.Row():
            login_btn = gr.Button("Login")
            register_btn = gr.Button("Register")
        output = gr.Textbox(label="Status")
        
        login_btn.click(login_user, inputs=[username, password, state], outputs=[gr.State(), output])
        register_btn.click(register_user, inputs=[username, password], outputs=output)
    
    with gr.Tab("Chat Agent", visible=False) as chat_tab:
        chat = gr.ChatInterface(
            chat_fn,
            additional_inputs=[state],
            textbox=gr.Textbox(placeholder="Ask about code or paste a chart URL (e.g., https://stockchart.com/image.png)"),
            title="Coding & Chart Analysis (Streaming)",
            description="Handles text/coding with grok-code-fast-1; auto-switches for images.",
            examples=["How to sort a list in Python?", "Describe this stock chart: https://example.com/stock.png"],
        )
    
    with gr.Tab("Video Overlay", visible=False) as video_tab:
        with gr.Row():
            base_upload = gr.Video(label="Base Video")
            ghost_upload = gr.Video(label="Ghost Video (Overlay)")
        alpha_slider = gr.Slider(0.1, 1.0, value=0.5, label="Ghost Opacity (Alpha)")
        base_start = gr.Number(value=0.0, label="Base Start (seconds)")
        ghost_start = gr.Number(value=0.0, label="Ghost Start (seconds)")
        duration = gr.Number(value=None, label="Duration (seconds, optional)")
        process_btn = gr.Button("Generate Overlaid MP4")
        output_video = gr.Video(label="Output MP4")
        status = gr.Textbox(label="Status")
        
        process_btn.click(
            process_videos,
            inputs=[base_upload, ghost_upload, alpha_slider, base_start, ghost_start, duration, state],
            outputs=[output_video, status]
        )
    
    # Show tabs on successful login
    def show_tabs(success: bool):
        return gr.update(visible=success), gr.update(visible=success)
    
    login_btn.click(show_tabs, inputs=gr.State(), outputs=[chat_tab, video_tab])

demo.launch(share=True, server_name="0.0.0.0", server_port=7860, auth=None)  #